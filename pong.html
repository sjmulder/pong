<!DOCTYPE html>
<html>
	<meta content-type=utf-8>
	<title>Pong</title>
	<style>
		canvas { border: 1px solid gray; }
	</style>
	<h1>Pong</h1>
	<canvas id="game-canvas" width="800" height="500"></canvas>
	<script>
		(function() {
			var gameSettings = {
				canvasSize: { x: 800, y: 500 },
				paddles: {
					paddleSize: { x: 15, y: 75 },
					speed: 400
				},
				ball: {
					ballSize: { x: 15, y: 15 },
					speed: { x: 200, y: 200 },
					maxSpeed: { x: 600, y: 600 },
					speedAdjustmentFactor: 1.1
				},
				paddleMargin: 50,
				startPause: 1,
				stepSize: 0.02
			};

			var canvas = document.getElementById('game-canvas');
			var context = canvas.getContext('2d');

			function newPaddlePos(paddleIndex) {
				var pos = {}
				pos.y = gameSettings.canvasSize.y / 2 - gameSettings.paddles.paddleSize.y / 2;
				if (paddleIndex == 0) {
					pos.x = gameSettings.paddleMargin;
				} else {
					pos.x = gameSettings.canvasSize.x - gameSettings.paddleMargin - 
						gameSettings.paddles.paddleSize.x;
				}
				return pos;
			}
			
			function newBallPos() {
				var canvasSize = gameSettings.canvasSize;
				var ballSize = gameSettings.ball.ballSize;
				return {
					x: canvasSize.x / 2 - ballSize.x / 2,
					y: canvasSize.y / 2 - ballSize.y / 2
				};
			}
			
			function newBallVelocity() {
				var speed = gameSettings.ball.speed;
				return {
					x: (Math.round(Math.random()) * 2 - 1) * speed.x,
					y: (Math.round(Math.random()) * 2 - 1) * speed.y
				}
			}
			
			function newGameState() {
				return {
					paddles: [
						{ pos: newPaddlePos(0), moveUp: false, moveDown: false, vel: { x: 0, y: 0 } }, 
						{ pos: newPaddlePos(1), moveUp: false, moveDown: false, vel: { x: 0, y: 0 } }
					],
					ball: {
						pos: newBallPos(),
						vel: newBallVelocity()
					}
				};
			}
			
			function render(gameState) {
				function clearCanvas() {
					context.clearRect(0, 0, gameSettings.canvasSize.x, gameSettings.canvasSize.y);
				}

				function drawPaddle(pos) {
					var paddleSize = gameSettings.paddles.paddleSize;
					context.fillRect(pos.x, pos.y, paddleSize.x, paddleSize.y);
				}

				function drawBall(pos) {
					var ballSize = gameSettings.ball.ballSize;
					context.fillRect(pos.x, pos.y, ballSize.x, ballSize.y);
				}
				
				clearCanvas();
				drawPaddle(gameState.paddles[0].pos);
				drawPaddle(gameState.paddles[1].pos);
				drawBall(gameState.ball.pos);
			}
			
			function rectsIntersect(origin1, size1, origin2, size2) {
				var right1 = origin1.x + size1.x;
				var right2 = origin2.x + size2.x;
				var bottom1 = origin1.y + size1.y;
				var bottom2 = origin2.y + size2.y;

				if (bottom1 < origin2.y) { return false; }
				if (origin1.y > bottom2) { return false; }
				if (right1 < origin2.x) { return false; }
				if (origin1.x > right2) { return false; }
				
				return true;
			}
			
			function step(gameState, delta, endCallback) {
				function stepMove(obj) {
					obj.pos.x += obj.vel.x * delta;
					obj.pos.y += obj.vel.y * delta;
				}
				
				function bounceBall(ball) {
					var ballSize = gameSettings.ball.ballSize;
					var canvasSize = gameSettings.canvasSize;
					
					if (ball.vel.y < 0 && ball.pos.y <= 0) {
						ball.vel.y *= -1;
					}
					if (ball.vel.y > 0 && ball.pos.y + ballSize.y >= canvasSize.y) {
						ball.vel.y *= -1;
					}
				}
				
				function ballOutOfScreen(ball) {
					return ball.pos.x + gameSettings.ball.ballSize.x <= 0 ||
						ball.pos.x >= gameSettings.canvasSize.x;
				}
				
				function applyPlayerInput(paddle) {
					var paddleSpeed = gameSettings.paddles.speed;
					paddle.vel.y = 0;
					if (paddle.moveUp)   { paddle.vel.y -= paddleSpeed; }
					if (paddle.moveDown) { paddle.vel.y += paddleSpeed; }
				}
				
				function checkCollissions(ball) {
					var ballSize = gameSettings.ball.ballSize;
					var paddleSize = gameSettings.paddles.paddleSize;
					var p1 = gameState.paddles[0];
					var p2 = gameState.paddles[1];
					
					var bounce = ball.vel.x < 0 ?
						rectsIntersect(ball.pos, ballSize, p1.pos, paddleSize) :
						rectsIntersect(ball.pos, ballSize, p2.pos, paddleSize);
					
					if (bounce) {
						var factor = gameSettings.ball.speedAdjustmentFactor;
						var maxSpeed = gameSettings.ball.maxSpeed;
						
						ball.vel.x = Math.min(maxSpeed.x, ball.vel.x * -factor);
						ball.vel.y = Math.min(maxSpeed.y, ball.vel.y * factor);
					}
				}
				
				for (var i = 0; i < gameState.paddles.length; i++) {
					var paddle = gameState.paddles[i];
					applyPlayerInput(paddle);
					stepMove(paddle);
				}

				stepMove(gameState.ball);
				bounceBall(gameState.ball);
				checkCollissions(gameState.ball);
				
				if (ballOutOfScreen(gameState.ball)) {
					endCallback();
				}
			}

			function playGame() {
				var gameState = newGameState();
				
				function keyChange(event, down) {
					var p1 = gameState.paddles[0];
					var p2 = gameState.paddles[1];
					switch (event.keyCode) {
						case 87: /* W    */ p1.moveUp   = down; break;
						case 83: /* S    */ p1.moveDown = down; break;
						case 38: /* up   */ p2.moveUp   = down; break;
						case 40: /* down */ p2.moveDown = down; break;
					}
				}
				
				function keyDown(event) {
					keyChange(event, true);
				}
				
				function keyUp(event) {
					keyChange(event, false);
				}
				
				window.addEventListener('keydown', keyDown, false);
				window.addEventListener('keyup', keyUp, false);
				
				function runGame() {
					render(gameState);
					var gameFinished = false;
					step(gameState, gameSettings.stepSize, function() {
						gameFinished = true;
						gameState = newGameState();
						render(gameState);
						setTimeout(function() {
							runGame();
						}, gameSettings.startPause * 1000)
					});
					if (!gameFinished) {
						setTimeout(function() { 
							runGame(); 
						}, gameSettings.stepSize * 1000);
					}
				};
				
				render(gameState);
				setTimeout(function() {
					runGame();
				}, gameSettings.startPause * 1000);
			}
			
			playGame();
		})();
	</script>
</html>